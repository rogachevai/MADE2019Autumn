/* Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера n.
Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло
на позиции с индексом k (0..n-1) в отсортированном массиве. Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении.
Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного.
Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы.
Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.
*/
#include <iostream>
#include <assert.h>

using namespace std;


int Partition( int* a, int n ) {
    int Last = n-1;
    int pivotIndex = rand()%n; //Выбор согласно условию задания
    swap(a[pivotIndex],a[Last]);

    int i = 0; // начало группы элементов, строго бОльших опорного.
    int j = 0; // первый нерассмотренный элемент.
    while( j<n-1 ) {
        if (a[j]>a[Last]){
            j++; // Если j-й элемент больше опорного, то сдвигаем j.
        } else { //Если он не больше опорного, то
            swap(a[i],a[j]); // меняем a[i] и a[j] местами
            i++; //  сдвигаем i и сдвигаем j.
            j++;
        }
    }
    swap (a[i],a[Last]); // В конце работы алгоритма меняем опорный и элемент,
    // на который указывает итератор i.
    return i;
}

int kStat(int* a, int n, int k){ // Поик k-й статистики
    int First=0;
    int Last=n;
    int p_ind=0;
    while (true){
        p_ind= Partition(a+First,Last-First); // Пробуем найти
        p_ind+=First;
        if (k<p_ind){ // Если меньше- ищем в левой части
            Last=p_ind; // указывая в качестве конца куска индекс, полученный из партишна
        } else if (k>p_ind){ // Если больше - аналогично, в правой части,
            First=p_ind+1; // смещая начало куска
        } else { //если нашли
            return a[k];
        }
    }
}


int main() {
    int n=0;
    int k =0;
    cin>>n>>k;
    assert (n>k);
    int* a= new int [n];
    for (int i=0; i<n;++i){
        cin>>a[i];
    }
    cout<<kStat(a,n,k);
    delete [] a;
    return 0;
}